#!/usr/bin/perl

# Copyright (C) 2018-2020 X2Go Project - https://wiki.x2go.org
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

# Disable some Perl::Critic violations.
#
# I like parentheses.
## no critic (ProhibitParensWithBuiltins)
#
# It's recommended not to use the constant pragma, but we don't want to use
# non-core modules like Readonly.
## no critic (ValuesAndExpressions::ProhibitConstantPragma)

use strict;
use warnings;

# Enable full Unicode handling, if possible.
use 5.012;

# Enable UTF-8 encoded data in the script itself.
use utf8;

# Make text coding issues fatal.
use warnings  qw (FATAL utf8);

#use X2Go::Utils qw (is_int);
use English qw (-no_match_vars);
use Getopt::Long qw (GetOptionsFromArray);
use Pod::Usage;
use Storable qw (dclone);
use Data::Dumper qw (Dumper);
use X2Go::Server::Agent::NX::Options;
use MIME::Base64 qw (encode_base64);
use List::Util qw (max);
use Encode qw (encode decode);

# Convert data in ARGV.
exit (Main (map { decode ("UTF-8", $_, Encode::FB_CROAK); } @ARGV));

BEGIN {
}

# No code past this point should be getting executed!

# These are actually supposed to be enums, but since Perl doesn't have a
# proper way of creating enums (at least not natively), we'll emulate that
# using list constants.
# The syntax is ( q{stringified mode name}, enum_value ).
#
# Make sure that enum_value is always a power of two!
use constant MODE_INVALID_DATA => ( q{invalid}, 0 );
use constant MODE_TRANSFORM_DATA => ( q{transform}, 1 );
use constant MODE_EXTRACT_DATA => ( q{extract}, 2 );
use constant MODES => ( \&MODE_TRANSFORM_DATA, \&MODE_EXTRACT_DATA );

# Helper function handling unknown options or ignoring the well-known
# separator. It scans for options until hitting the first non-option entry.
#
# Takes an array reference with unparsed options and a boolean value denoting
# whether the separating "--" pseudo-option should be skipped or not as its
# parameters.
#
# Returns an array reference containing a boolean value denoting whether a
# separating "--" pseudo-option has been found *and* skipping it was requested,
# and the sanitized version of the original array reference.
#
# On error, returns undef.
sub sanitize_program_options {
  my $ret = undef;
  my $error_detected = 0;
  my $found_separator = 0;

  my $args = shift;
  my $skip_separator = shift;

  if ((!(defined ($args))) || ('ARRAY' ne ref ($args))) {
    print {*STDERR} "Invalid argument array reference passed to program sanitization helper, erroring out.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    if (!(defined ($skip_separator))) {
      print {*STDERR} "No skip-separator parameter passed to program sanitization helper, erroring out.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    $args = dclone ($args);

    ## no critic (ControlStructures::ProhibitCStyleForLoops)
    for (my $cur_arg = shift (@{$args}); defined ($cur_arg); $cur_arg = shift (@{$args})) {
    ## critic (ControlStructures::ProhibitCStyleForLoops)
      if (q{-} eq substr ($cur_arg, 0, 1)) {
        # Looks like an option so far. Let's continue scanning.

        if (1 == length ($cur_arg)) {
          # But isn't a real option. Add back to argument list and stop
          # processing.
          unshift (@{$args}, $cur_arg);
          last;
        }
        elsif ((2 == length ($cur_arg)) && (q{-} eq substr ($cur_arg, 1, 1))) {
          if ($skip_separator) {
            # Found separating "--" pseudo-option, but skipping requested. Only
            # set the boolean value for our return value and make sure that we
            # don't skip another separating pseudo-option if it comes up again
            # right next to this one.
            $found_separator = 1;
            $skip_separator = 0;
          }
          else {
            # Not skipping separating "--" pseudo-option - i.e., we'll treat this
            # as a non-option.
            unshift (@{$args}, $cur_arg);
            last;
          }
        }
        else {
          # Otherwise this is an actual option.
          # We either want to error out, if no previous separating "--"
          # pseudo-option was found, or ignore it.
          # The weird 0 + (...) construct here is forcing an arithmetic
          # context. Otherwise, the interpreter might use a string context,
          # in which the value "0" is dualvar'd to both an arithmetic 0 and
          # an empty string.
          my $separator_found = (0 + ((!($skip_separator)) | ($found_separator)));
          if ($separator_found) {
            # Put back into array. We'll handle this as not-an-option.
            unshift (@{$args}, $cur_arg);
            last;
          }
          else {
            print {*STDERR} q{Unknown option encountered: } . $cur_arg . "; erroring out.\n";
            $error_detected = 1;
            last;
          }
        }
      }
      else {
        # Definitely not an option, add back to array.
        unshift (@{$args}, $cur_arg);
        last;
      }
    }
  }

  if (!($error_detected)) {
    $ret = [ $found_separator, $args ];
  }

  return $ret;
}

# Helper function handling mode abbreviations.
#
# Takes a string, which represents a (potentially abbreviated) mode name as
# its only parameter.
#
# Returns an array reference containing a count, denoting how often the
# abbreviated mode matched the known modes and a reference to an internal mode
# element.
#
# On error, returns undef.
sub handle_mode_abbrev {
  my $ret = undef;
  my $error_detected = 0;
  my $found = 0;
  my $mode_parse = \&MODE_INVALID_DATA;

  my $mode = shift;

  if (!(defined ($mode))) {
    print {*STDERR} "Invalid mode argument passed to mode abbreviation selection helper, erroring out.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    my $length = length ($mode);

    if ($length < max (map { length ((&{$_}())[0]); } (MODES))) {
      foreach my $elem (MODES) {
        if (substr ((&{$elem}())[0], 0, $length) eq $mode) {
          if (!($found)) {
            $mode_parse = $elem;
          }
          ++$found;
        }
      }
    }

    $ret = [ $found, $mode_parse ];
  }

  return $ret;
}

# Helper function handling the parsing and setting of program modes.
#
# Takes a string, which represents a (potentially abbreviated) mode name, a
# boolean denoting transformation mode and a boolean denoting extract mode as
# its parameters.
#
# Returns a mode enum element.
#
# On error, returns the mode number corresponding to MODE_INVALID.
sub handle_mode {
  my $ret = (MODE_INVALID_DATA)[1];
  my $error_detected = 0;
  my $mode_aggregate = 0;
  my $mode_parse = \&MODE_INVALID_DATA;

  my $mode = shift;
  my $transform = shift;
  my $extract = shift;

  if (!(defined ($mode))) {
    print {*STDERR} "Invalid mode argument passed to mode selection helper, erroring out.\n";
    $error_detected = 1;
  }

  if ((!($error_detected)) && (!(defined ($transform)))) {
    print {*STDERR} "Invalid transformation argument passed to mode selection helper, erroring out.\n";
    $error_detected = 1;
  }

  if ((!($error_detected)) && (!(defined ($extract)))) {
    print {*STDERR} "Invalid extract argument passed to mode selection helper, erroring out.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    # Next check for mutual exclusiveness regarding modes.
    if ($transform) {
      $mode_aggregate |= (&{(MODES)[0]}())[1];
    }

    if ($extract) {
      $mode_aggregate |= (&{(MODES)[1]}())[1];
    }

    if (($mode_aggregate) && ($mode_aggregate & ($mode_aggregate - 1))) {
      print {*STDERR} "Mutually exclusive modes specified, erroring out.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    if ($mode ne q{}) {
      # Mode has been passed, support substrings of the actual modes.
      my $found = 0;

      my %modes = ();
      foreach my $elem (MODES) {
        $modes{(&{$elem}())[0]} = 1;
      }

      my $abbrev_ret = handle_mode_abbrev ($mode);

      if (!(defined ($abbrev_ret))) {
        print {*STDERR} 'Unable to parse given mode (' . $mode . ") as an abbreviation, erroring out.\n";
        $error_detected = 1;
      }
      elsif (2 != scalar (@{$abbrev_ret})) {
        print {*STDERR} 'Return value of abbreviation parsing for mode (' . $mode . ") has a wrong format, erroring out.\n";
        $error_detected = 1;
      }
      else {
        # Check data.
        my $first_reftype = ref ($abbrev_ret->[0]);
        my $second_reftype = ref ($abbrev_ret->[1]);
        if ((q{} ne $first_reftype) || (q{CODE} ne $second_reftype)) {
          print {*STDERR} 'Return value of abbreviation parsing for mode (' . $mode . ") has a wrong format.\n";
          print {*STDERR} 'Expected scalar (empty string), got "' . $first_reftype . '" and CODE, got "' . $second_reftype . q{"} . "\n";
          print {*STDERR} "Erroring out.\n";
          $error_detected = 1;
        }
        else {
          # Unpack return data.
          $found = shift (@{$abbrev_ret});
          $mode_parse = shift (@{$abbrev_ret});
        }
      }

      # Now check if value matches a known one.
      if ((!($error_detected)) && (!($found))) {
        foreach my $elem (MODES) {
          if (exists ($modes{(&{$elem}())[0]})) {
            $mode_parse = $elem;
            $found = 1;
            last;
          }
        }
      }

      if (!($error_detected)) {
        if (!($found)) {
          print {*STDERR} 'Invalid mode specified (' . $mode . "), erroring out.\n";
          $error_detected = 1;
        }
        elsif (1 < $found) {
          print {*STDERR} 'Supplied mode (' . $mode . ") is ambiguous, erroring out.\n";
          $error_detected = 1;
        }
      }
    }
  }

  # Okay, now check for mutual exclusiveness and map to return value.
  if (!($error_detected)) {
    $ret = ($mode_aggregate | (&{$mode_parse}())[1]);

    if (($ret) && ($ret & ($ret - 1))) {
      print {*STDERR} "Mutually exclusive modes specified, erroring out.\n";
      $error_detected = 1;
    }
  }

  if ($error_detected) {
    $ret = (MODE_INVALID_DATA)[1];
  }

  return $ret;
}

# Helper function applying a transformation to an intermediate options string.
#
# Takes an intermediate options string, a transformation string and a boolean
# value indicating whether debugging is turned on or off as its parameters.
#
# Returns a modified intermediate options string.
#
# On error, returns undef.
sub apply_transformation {
  my $ret = undef;
  my $error_detected = 0;

  my $intermediate = shift;
  my $transform = shift;
  my $debug = shift;

  if (!(defined ($intermediate))) {
    print {*STDERR} "Invalid intermediate argument passed to transformation helper, erroring out.\n";
    $error_detected = 1;
  }

  if ((!($error_detected)) && (!(defined ($transform)))) {
    print {*STDERR} "Invalid transformation argument passed to transformation helper, erroring out.\n";
    $error_detected = 1;
  }

  if ((!($error_detected)) && (!(defined ($debug)))) {
    print {*STDERR} "Invalid debug argument passed to transformation helper, erroring out.\n";
    $error_detected = 1;
  }

  my $interpreted_transform_ref = undef;

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Parsing current raw transformation option: ' . Dumper ($transform);
    }

    $interpreted_transform_ref = X2Go::Server::Agent::NX::Options::interpret_transform ($transform);

    if (!(defined ($interpreted_transform_ref))) {
      print {*STDERR} "Invalid transformation passed, aborting.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    my ($transform_mode, $sanitized_transform) = @{$interpreted_transform_ref};

    if ($debug) {
      print {*STDERR} 'Parsed raw transformation option into mode \'' . $transform_mode . '\' and sanitized transform option \'' . Dumper ($sanitized_transform) . "'\n";
    }

    $intermediate = X2Go::Server::Agent::NX::Options::transform_intermediate ($intermediate, $transform_mode, $sanitized_transform);

    if (!(defined ($intermediate))) {
      print {*STDERR} "Error while transforming intermediate representation, aborting.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Dumping transformed intermediate array: ' . Dumper ($intermediate);
    }

    $ret = $intermediate;
  }

  return $ret;
}

# Main function, no code outside of it shall be executed.
#
# Expects @ARGV to be passed in.
## no critic (NamingConventions::Capitalization)
sub Main {
## critic (NamingConventions::Capitalization)
  my @program_arguments = @_;
  my $error_detected = 0;
  my $found_separator = 0;

  Getopt::Long::Configure ('gnu_getopt', 'no_auto_abbrev', 'pass_through');

  my $help = 0;
  my $man = 0;
  my $debug = 0;
  my $compact = 0;
  my $mode_transform = 0;
  my $mode_extract = 0;
  my $mode_arg = q{};
  GetOptionsFromArray (\@program_arguments, 'help|?|h' => \$help,
                                            'man' => \$man,
                                            'debug|d' => \$debug,
                                            'compact|c' => \$compact,
                                            'transform|t' => \$mode_transform,
                                            'extract|e' => \$mode_extract,
                                            'mode|m=s' => \$mode_arg) or pod2usage (2);

  if ($help) {
    pod2usage (1);
  }

  if ($man) {
    pod2usage (-verbose => 2, -exitval => 3);
  }

  my $mode = handle_mode ($mode_arg, $mode_transform, $mode_extract);

  if ($debug) {
    print {*STDERR} 'Parsed mode as: ' . $mode . "\n";
  }

  if ((MODE_INVALID_DATA)[1] == $mode) {
    $error_detected = 4;
  }

  my $sanitized_options = undef;

  if (!($error_detected)) {
    $sanitized_options = sanitize_program_options (\@program_arguments, (!($found_separator)));

    if (!(defined ($sanitized_options))) {
      pod2usage (-exitval => 'NOEXIT');
      $error_detected = 5;
    }
  }

  my $options = undef;

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Sanitized program options string as: ' . Dumper ($sanitized_options);
    }

    # The shift () operations here actually shift the outer array, not the
    # inner elements.
    # This can be very confusing.
    # The return value is an array consisting of a boolean value and an array
    # reference.
    #
    # Thus, shifting once returns the boolean value, while shifting again
    # returns the options array reference. Crucially, no shift () operation
    # here modifies the modified options array.
    $found_separator |= (0 + shift (@{$sanitized_options}));
    $sanitized_options = shift (@{$sanitized_options});
    @program_arguments = @{$sanitized_options};

    $options = shift (@program_arguments);

    if (!(defined ($options))) {
      print {*STDERR} "No options string given, aborting.\n";
      $error_detected = 6;
    }
  }

  my $intermediate = undef;

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Fetched options string as: ' . Dumper (\$options);
    }

    $intermediate = X2Go::Server::Agent::NX::Options::parse_options ($options);

    if (!(defined ($intermediate))) {
      print {*STDERR} "Unable to parse options string, aborting.\n";
      $error_detected = 7;
    }
  }

  if (!($error_detected)) {
    $sanitized_options = sanitize_program_options (\@program_arguments, (!($found_separator)));

    if (!(defined ($sanitized_options))) {
      pod2usage (-exitval => 'NOEXIT');
      $error_detected = 8;
    }
  }

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Sanitized program options string as: ' . Dumper ($sanitized_options);
      print {*STDERR} 'Dumping intermediate array after initial parsing: ' . Dumper ($intermediate);
    }

    if (((MODE_EXTRACT_DATA)[1] == $mode) || ($compact)) {
      $intermediate = X2Go::Server::Agent::NX::Options::compact_intermediate ($intermediate);

      if (!(defined ($intermediate))) {
        print {*STDERR} "Unable to compact intermediate options representation, aborting.\n";
        $error_detected = 9;
      }
      elsif ($debug) {
        print {*STDERR} 'Dumping intermediate array after compacting: ' . Dumper ($intermediate);
      }
    }
  }

  my $out = undef;

  if (!($error_detected)) {
    $found_separator |= (0 + shift (@{$sanitized_options}));
    $sanitized_options = shift (@{$sanitized_options});
    @program_arguments = @{$sanitized_options};

    my $operation = 0;

    while (defined (my $cur_arg = shift (@program_arguments))) {
      $operation = 1;

      if ((MODE_TRANSFORM_DATA)[1] == $mode) {
        $intermediate = apply_transformation ($intermediate, $cur_arg, $debug);

        if (!(defined ($intermediate))) {
          print {*STDERR} 'Unable to apply transformation "' . $cur_arg . '"' . ", aborting.\n";
          $error_detected = 10;
          last;
        }
      }
      elsif ((MODE_EXTRACT_DATA)[1] == $mode) {
        my $extract = extract_data ($intermediate, $cur_arg, $debug);

        if (!(defined ($extract))) {
          print {*STDERR} 'Unable to extract data for "' . $cur_arg . '"' . ", aborting.\n";
          $error_detected = 11;
        }
        else {
          # Convert into bytes.
          my $bytes = encode ("UTF-8", $extract, Encode::FB_CROAK);

          # Encode the data.
          my $base64 = MIME::Base64::encode_base64 ($extract, q{});

          if (!(defined ($out))) {
            # Create it.
            $out = $base64;
          }
          else {
            # Otherwise, append and make sure to separate fields.
            $out .= q{|} . $base64;
          }
        }
      }

      # Skip pseudo-option, if necessary.
      $sanitized_options = sanitize_program_options (\@program_arguments, (!($found_separator)));

      if (!(defined ($sanitized_options))) {
        pod2usage (-exitval => 'NOEXIT');
        $error_detected = 12;
        last;
      }
      elsif ($debug) {
        print {*STDERR} 'Sanitized program options string as: ' . Dumper ($sanitized_options);
      }

      $found_separator |= (0 + shift (@{$sanitized_options}));
      $sanitized_options = shift (@{$sanitized_options});
      @program_arguments = @{$sanitized_options};
    }

    if ((!($error_detected)) && (!($operation))) {
      print {*STDERR} "No operation carried out, aborting.\n";
      $error_detected = 13;
    }
  }

  if (!($error_detected)) {
    if ((MODE_TRANSFORM_DATA)[1] == $mode) {
      $out = X2Go::Server::Agent::NX::Options::intermediate_to_string ($intermediate);

      if (!(defined ($out))) {
        print {*STDERR} "Unable to transform intermediate back into string, aborting.\n";
        $error_detected = 14;
      }
    }
  }

  if (!($error_detected)) {
    print {*STDOUT} $out . "\n";
  }

  return $error_detected;
}

__END__

=pod

=head1 NAME

x2goupdateoptionsstring - X2Go Agent Options String Manipulator

=head1 SYNOPSIS

=over

=item B<x2goupdateoptionsstring> B<--help>|B<-h>|B<-?>

=item B<x2goupdateoptionsstring> B<--man>

=item B<x2goupdateoptionsstring> [B<--compact>|B<-c>] [B<--debug>|B<-d>] [B<-->] I<options_string> [B<+>]|B<->I<key>[B<=>I<value>] ...

=back

=head1 DESCRIPTION

=for comment
Due to parser oddities, breaking a line during an L<dummy|text> formatter code
right after the separating pipe character will generate broken links.
Make sure to only break it during the description or, generally, on space
characters.
A workaround for this as been proposed in
https://github.com/Perl/perl5/issues/18305 .

B<x2goupdateoptionsstring> is a utility for manipulating options strings as
passed to B<X2Go/NX Agent>.
For more information about supported options strings, refer to the L<OPTIONS
STRINGS section in the X2Go::Server::Agent::NX::Options
documentation|X2Go::Server::Agent::NX::Options/OPTIONS STRINGS>.

Call it with optional flags, the options string as the first parameter and the
transformations to be carried out as additional parameters.
At least one additional parameter (i.e., a transformation) must be provided.
Transformations are described here briefly, but also in the L<TRANSFORMATIONS
section in the X2Go::Server::Agent::NX::Options
documentation|X2Go::Server::Agent::NX::Options/TRANSFORMATIONS>.

It can either add, remove or replace components.

To add or replace a component, pass I<key>[B<=>I<value>] or
B<+>I<key>[B<=>I<value>] as a parameter.
The latter syntax is useful if I<key> starts with a dash and would therefore
be interpreted as a removal operation.
If the options string does not include a B<key> key, it will be appended to
the end of the options string.
If it already exists, either with no value or a different value, the component
will be replaced with the provided value.

To fully remove a component, pass B<->I<key>.
To only remove it if it is set to a specific value, pass
B<->I<key>B<=>I<value>.

Use the B<--compact> option to minimize the original options string, removing
duplicated and empty entries.

Refer to the L<OPTIONS PARSING section|/OPTIONS PARSING> for a description of
when and how to terminate options passed to this program.

=head1 OPTIONS

=over 8

=item B<--help>|B<-?>|B<-h>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--debug>|B<-d>

Enables noisy debug output.

=item B<--compact>|B<-c>

Remove duplicate and empty entries after the initial parsing.
The order of arguments is preserved in a first-seen fashion.

=back

=head2 OPTIONS PARSING

You can terminate program options parsing via a standard double-dash (B<-->)
pseudo-option.
It is B<highly recommended> to always do so.

If you pass removal transformation operations, passing the options terminator
is B<mandatory>, even if no actual options are used.
Otherwise, transformation operations will be interpreted as options to the
program, which will almost certainly lead to an error.

For example, passing C<-clipboard> as a transformation operation without a
previous options terminator will be interpreted as the option C<-c>, with the
rest of the string modified into C<-lipboard>.
Since this program does not accept an option called C<-l>, it will terminate
with an error.
Even then, this is certainly not what the original transformation operation
was supposed to represent.

=head1 EXAMPLES

For an options string such as

 nx/nx,clipboard=both,foo:50

=over 2

calling C<x2goupdateoptionsstring '--' 'nx/nx,clipboard=both,foo:50'
'-clipboard'> shall return

 nx/nx,foo:50

while calling C<x2goupdateoptionsstring '--' 'nx/nx,clipboard=both,foo:50'
'-clipboard=server'> shall return

 nx/nx,clipboard=both,foo:50

Calling C<x2goupdateoptionsstring '--' 'nx/nx,clipboard=both,foo:50' 'bar'>
shall return

 nx/nx,clipboard=both,foo,bar:50

and calling C<x2goupdateoptionsstring '--' 'nx/nx,clipboard=both,foo:50'
'+-bar' 'foo=gulp' '-clipboard=client'> shall return

 nx/nx,clipboard=both,foo=gulp,-bar:50

=back

For an options string such as

 nx/nx,clipboard=both,foo=bar,bar=baz,foo=oof:50

=over 2

you can get a compacted version by cheating a bit and providing a
transformation which will certainly be a no-operation using
C<x2goupdateoptionsstring '-c' '--'
'nx/nx,clipboard=both,foo=bar,bar=baz,,foo=oof,:50' '-'>, which shall return

 nx/nx,clipboard=both,foo=oof,bar=baz:50

=back

=head1 AUTHOR

This manual has been written by
Mihai Moldovan L<E<lt>ionic@ionic.deE<gt>|mailto:ionic@ionic.de> for the X2Go
project (L<https://www.x2go.org|https://www.x2go.org>).

=cut
