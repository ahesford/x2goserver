#!/usr/bin/perl

# Copyright (C) 2018-2020 X2Go Project - https://wiki.x2go.org
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

# Disable some Perl::Critic violations.
## no critic (ProhibitParensWithBuiltins)

use strict;
use warnings;

#use X2Go::Utils qw (is_int);
use English qw (-no_match_vars);
use Getopt::Long qw (GetOptionsFromArray);
use Pod::Usage;
use Storable qw (dclone);
use Data::Dumper qw (Dumper);
use X2Go::Server::Agent::NX::Options;

exit (Main (@ARGV));

BEGIN {
}

# No code past this point should be getting executed!

# Helper function handling unknown options or ignoring the well-known
# separator. It scans for options until hitting the first non-option entry.
#
# Takes an array reference with unparsed options and a boolean value denoting
# whether the separating "--" pseudo-option should be skipped or not as its
# parameters.
#
# Returns an array reference containing a boolean value denoting whether a
# separating "--" pseudo-option has been found *and* skipping it was requested,
# and the sanitized version of the original array reference.
#
# On error, returns undef.
sub sanitize_program_options {
  my $ret = undef;
  my $error_detected = 0;
  my $found_separator = 0;

  my $args = shift;
  my $skip_separator = shift;

  if ((!(defined ($args))) || ('ARRAY' ne ref ($args))) {
    print {*STDERR} "Invalid argument array reference passed to program sanitization helper, erroring out.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    if (!(defined ($skip_separator))) {
      print {*STDERR} "No skip-separator parameter passed to program sanitization helper, erroring out.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    $args = dclone ($args);

    ## no critic (ControlStructures::ProhibitCStyleForLoops)
    for (my $cur_arg = shift (@{$args}); defined ($cur_arg); $cur_arg = shift (@{$args})) {
    ## critic (ControlStructures::ProhibitCStyleForLoops)
      if (q{-} eq substr ($cur_arg, 0, 1)) {
        # Looks like an option so far. Let's continue scanning.

        if (1 == length ($cur_arg)) {
          # But isn't a real option. Add back to argument list and stop
          # processing.
          unshift (@{$args}, $cur_arg);
          last;
        }
        elsif ((2 == length ($cur_arg)) && (q{-} eq substr ($cur_arg, 1, 1))) {
          if ($skip_separator) {
            # Found separating "--" pseudo-option, but skipping requested. Only
            # set the boolean value for our return value.
            $found_separator = 1;
          }
          else {
            # Not skipping separating "--" pseudo-option - i.e., we'll treat this
            # as a non-option.
            unshift (@{$args}, $cur_arg);
            last;
          }
        }
        else {
          # Otherwise this is an actual option.
          # We either want to error out, if no previous separating "--"
          # pseudo-option was found, or ignore it.
          # The weird 0 + (...) construct here is forcing an arithmetic
          # context. Otherwise, the interpreter might use a string context,
          # in which the value "0" is dualvar'd to both an arithmetic 0 and
          # an empty string.
          my $separator_found = (0 + ((!($skip_separator)) | ($found_separator)));
          if ($separator_found) {
            # Put back into array. We'll handle this as not-an-option.
            unshift (@{$args}, $cur_arg);
            last;
          }
          else {
            print {*STDERR} q{Unknown option encountered: } . $cur_arg . "; erroring out.\n";
            $error_detected = 1;
            last;
          }
        }
      }
      else {
        # Definitely not an option, add back to array.
        unshift (@{$args}, $cur_arg);
        last;
      }
    }
  }

  if (!($error_detected)) {
    $ret = [ $found_separator, $args ];
  }

  return $ret;
}

# Main function, no code outside of it shall be executed.
#
# Expects @ARGV to be passed in.
## no critic (NamingConventions::Capitalization)
sub Main {
## critic (NamingConventions::Capitalization)
  my @program_arguments = @_;
  my $error_detected = 0;
  my $found_separator = 0;

  Getopt::Long::Configure ('gnu_getopt', 'no_auto_abbrev', 'pass_through');

  my $help = 0;
  my $man = 0;
  my $debug = 0;
  my $compact = 0;
  GetOptionsFromArray (\@program_arguments, 'help|?|h' => \$help,
                                            'man' => \$man,
                                            'debug|d' => \$debug,
                                            'compact|c' => \$compact) or pod2usage (2);

  if ($help) {
    pod2usage (1);
  }

  if ($man) {
    pod2usage (-verbose => 2, -exitval => 3);
  }

  my $sanitized_options = sanitize_program_options (\@program_arguments, (!($found_separator)));

  if (!(defined ($sanitized_options))) {
    pod2usage (-exitval => 'NOEXIT');
    $error_detected = 4;
  }

  my $options = undef;

  if (!($error_detected)) {
    $found_separator |= (0 + shift (@{$sanitized_options}));
    $sanitized_options = shift (@{$sanitized_options});
    @program_arguments = @{$sanitized_options};

    $options = shift (@program_arguments);

    if (!(defined ($options))) {
      print {*STDERR} "No options string given, aborting.\n";
      $error_detected = 5;
    }
  }

  my $intermediate = undef;

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Fetched options string as: ' . Dumper (\$options);
    }

    $intermediate = X2Go::Server::Agent::NX::Options::parse_options ($options);

    if (!(defined ($intermediate))) {
      print {*STDERR} "Unable to parse options string, aborting.\n";
      $error_detected = 6;
    }
  }

  if (!($error_detected)) {
    $sanitized_options = sanitize_program_options (\@program_arguments, (!($found_separator)));

    if (!(defined ($sanitized_options))) {
      pod2usage (-exitval => 'NOEXIT');
      $error_detected = 7;
    }
  }

  if (!($error_detected)) {
    if ($debug) {
      print {*STDERR} 'Dumping intermediate array after initial parsing: ' . Dumper ($intermediate);
    }

    if ($compact) {
      $intermediate = X2Go::Server::Agent::NX::Options::compact_intermediate ($intermediate);

      if (!(defined ($intermediate))) {
        print {*STDERR} "Unable to compact intermediate options representation, aborting.\n";
        $error_detected = 8;
      }
      elsif ($debug) {
        print {*STDERR} 'Dumping intermediate array after compacting: ' . Dumper ($intermediate);
      }
    }
  }

  if (!($error_detected)) {
    $found_separator |= (0 + shift (@{$sanitized_options}));
    $sanitized_options = shift (@{$sanitized_options});
    @program_arguments = @{$sanitized_options};

    my $transformed = 0;

    # Nasty trick (to some degree): "do"-blocks are not recognized as loops by
    # Perl, but we could wrap the body in another block, which WILL BE recognized
    # as a loop (one, that only executes once), oddly enough. However, using
    # "last" won't work in such a situation, but rather behave like "next".
    # Worse, the condition will also not be checked in such a case.
    # Thus, we'd better use a real loop.
    while (defined (my $cur_transform = shift (@program_arguments))) {
      $transformed = 1;

      if ($debug) {
        print {*STDERR} 'Parsing current raw transformation option: ' . Dumper ($cur_transform);
      }

      my $interpreted_transform_ref = X2Go::Server::Agent::NX::Options::interpret_transform ($cur_transform);

      if (!(defined ($interpreted_transform_ref))) {
        print {*STDERR} "Invalid transformation passed, aborting.\n";
        $error_detected = 9;
        last;
      }

      my ($transform_mode, $sanitized_transform) = @{$interpreted_transform_ref};

      if ($debug) {
        print {*STDERR} 'Parsed raw transformation option into mode \'' . $transform_mode . '\' and sanitized transform option \'' . Dumper ($sanitized_transform) . "'\n";
      }

      $intermediate = X2Go::Server::Agent::NX::Options::transform_intermediate ($intermediate, $transform_mode, $sanitized_transform);

      if (!(defined ($intermediate))) {
        print {*STDERR} "Error while transforming intermediate representation, aborting.\n";
        $error_detected = 10;
        last;
      }

      if ($debug) {
        print {*STDERR} 'Dumping transformed intermediate array: ' . Dumper ($intermediate);
      }

      # Skip pseudo-option, if necessary.
      $sanitized_options = sanitize_program_options (\@program_arguments, (!($found_separator)));

      if (!(defined ($sanitized_options))) {
        pod2usage (-exitval => 'NOEXIT');
        $error_detected = 11;
        last;
      }

      $found_separator |= (0 + shift (@{$sanitized_options}));
      $sanitized_options = shift (@{$sanitized_options});
      @program_arguments = @{$sanitized_options};
    }

    if ((!($error_detected)) && (!($transformed))) {
      print {*STDERR} "No transformation passed, aborting.\n";
      $error_detected = 12;
    }
  }

  my $out = undef;

  if (!($error_detected)) {
    $out = X2Go::Server::Agent::NX::Options::intermediate_to_string ($intermediate);

    if (!(defined ($out))) {
      print {*STDERR} "Unable to transform intermediate back into string, aborting.\n";
      $error_detected = 13;
    }
  }

  if (!($error_detected)) {
    print {*STDOUT} $out . "\n";
  }

  return $error_detected;
}

__END__

=pod

=head1 NAME

x2goupdateoptionsstring - X2Go Agent Options String Manipulator

=head1 SYNOPSIS

=over

=item B<x2goupdateoptionsstring> B<--help>|B<-h>|B<-?>

=item B<x2goupdateoptionsstring> B<--man>

=item B<x2goupdateoptionsstring> [B<--compact>|B<-c>] [B<--debug>|B<-d>] [B<-->] I<options_string> [B<+>]|B<->I<key>[B<=>I<value>] ...

=back

=head1 DESCRIPTION

B<x2goupdateoptionsstring> is a utility for manipulating options strings as
passed to B<X2Go/NX Agent>.

Call it with optional flags, the options string as the first parameter and the
options you want to manipulate as additional parameters.
At least one additional parameter (i.e., a transformation) must be provided.

It can either add, remove or replace components.

To add or replace a component, pass I<key>[B<=>I<value>] or
B<+>I<key>[B<=>I<value>] as a parameter.
The latter syntax is useful if I<key> starts with a dash and would therefore
be interpreted as a removal operation.
If the options string does not include a B<key> key, it will be appended to
the end of the options string.
If it already exists, either with no value or a different value, the component
will be replaced with the provided value.

To fully remove a component, pass B<->I<key>.
To only remove it if it is set to a specific value, pass
B<->I<key>B<=>I<value>.

Use the B<--compact> option to minimize the original options string, removing
duplicated and empty entries.

You can terminate program options parsing via a standard double-dash (B<-->)
pseudo-option.
It is recommended to always do so if you pass removal transformation
operations, even if no actual options are used to avoid misinterpreting such
transformation options as options/flags to the program.

=head1 OPTIONS

=over 8

=item B<--help>|B<-?>|B<-h>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--debug>|B<-d>

Enables noisy debug output.

=item B<--compact>|B<-c>

Remove duplicate and empty entries after the initial parsing.
The order of arguments is preserved in a first-seen fashion.

=back

=head1 EXAMPLE

For an options string such as

 nx/nx,clipboard=both,foo:50

calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50'
'-clipboard'> shall return

 nx/nx,foo:50

while calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50'
'-clipboard=server'> shall return

 nx/nx,clipboard=both,foo:50

Calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50' 'bar'> shall
return

 nx/nx,clipboard=both,foo,bar:50

and calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50' '+-bar'
'foo=gulp' '-clipboard=client'> shall return

 nx/nx,clipboard=both,foo=gulp,-bar:50

=head1 AUTHOR

This manual has been written by
Mihai Moldovan L<E<lt>ionic@ionic.deE<gt>|mailto:ionic@ionic.de> for the X2Go
project (L<https://www.x2go.org>).

=cut
