#!/usr/bin/perl

# Copyright (C) 2018 X2Go Project - https://wiki.x2go.org
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

use strict;
use warnings;

#use X2Go::Utils qw (is_int);
use English qw (-no_match_vars);
use Getopt::Long;
use Pod::Usage;
use Storable qw (dclone);
use Data::Dumper qw (Dumper);

# Accepts an option string and returns a reference to an array of hashes
# (actually hash references) corresponding to the parsed key-value pairs.
#
# Empty components are allowed, but will issue a warning message. In such a
# case, the hash at the corresponding array position will be empty.
#
# Keys that do not have a value assigned will be given a value of "undef" in
# order to be able to distinguish them from keys with an empty string as their
# value.
#
# Caveat: the last component will be split from the port definition. DO NOT
# SIMPLY JOIN THE LIST OR YOU WILL ADD A TRAILING COMMA! The port component
# hash retains the colon separator.
#
# On error, returns an undef reference.
sub parse_options {
  my $ret = undef;
  my @intermediate = ();
  my $error_detected = 0;
  my $options = shift;
  my $next_discard = shift;

  if (defined ($next_discard)) {
    print {*STDERR} "Multiple arguments passed in, all but the first one are ignored!\n";
  }

  if (!(defined ($options))) {
    print {*STDERR} "No argument provided for options string, returning undef.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    my @components = split (/,/sxm, $options, -1);
    foreach my $option (@components) {
      # We use undef to denote that some component was not provided at all
      # to disambiguate non-provided and empty strings.
      my ($key, $value) = (undef, undef);
      my %kv_hash = ();

      my @kv = split (/=/sxm, $option, 2);

      if (1 > scalar (@kv)) {
        print {*STDERR} "Options string has empty component, this is deprecated. Adding empty element.\n";

        push (@intermediate, \%kv_hash);
      }
      elsif (3 <= scalar (@kv)) {
        print {*STDERR} "Options string has three or more components, this is a bug in $PROGRAM_NAME. Erroring out.\n";
        $error_detected = 1;
        last;
      }
      else {
        $key = shift (@kv);
        $value = shift (@kv);

        # Add to hash - every hash will contain a single key-value pair only.
        $kv_hash{$key} = $value;

        # Then add the hash as an entry in our return array - by reference.
        push (@intermediate, \%kv_hash);
      }
    }

    # Special handling for the last option, which does not use a comma as the
    # delimiter but a colon.
    #
    # Note that it can either be part of the key or the value.
    if (!($error_detected)) {
      if ((0 < scalar (@intermediate)) && (defined ($intermediate[0]))) {
        my $last_hash_ref = pop (@intermediate);
        my $hash_count = 0;
        my $last_component = q{};
        my $in_value = 0;
        my $last_component_key = undef;

        # Fetch last component and check for sanity.
        # An empty hash is implicitly handled by initializing $last_component to
        # an empty string, which will fail the splitting later on.
        foreach my $key (keys %{$last_hash_ref}) {
          ++$hash_count;

          if (1 < $hash_count) {
            print {*STDERR} "More than one element found in last element's hash, this is a bug in $PROGRAM_NAME. Ignoring subsequent entries.\n";
            last;
          }

          $last_component = $last_component_key = $key;

          if (defined ($last_hash_ref->{$key})) {
            # If a value exists, the display specifier can not be part of the
            # key.
            $in_value = 1;
            $last_component = $last_hash_ref->{$key};
          }
        }

        # Don't use split() here. While we could use a more or less complex
        # regex to extract the last(!) port specifier only, this would render
        # the LIMIT parameter to split() useless (since additional capture
        # groups are not part of the limit).
        # Thus going the manual route here.
        my $last_pos = rindex ($last_component, q{:});

        if ($[ > $last_pos) {
          print {*STDERR} "No display port seperator found in the options string. Erroring out.\n";
          $error_detected = 1;
        }
        else {
          my $last_component_left = substr ($last_component, 0, $last_pos);
          my $last_component_right = substr ($last_component, $last_pos);

          my %last_component_hash = ();

          if ($in_value) {
            $last_component_hash{$last_component_key} = $last_component_left;
          }
          else {
            # Sanity check on the key. If it's empty, issue a warning and don't
            # use it.
            if (0 == length ($last_component_left)) {
              print {*STDERR} "Options string has empty component, this is deprecated. Adding empty element.\n";
            }
            else {
              $last_component_hash{$last_component_left} = undef;
            }
          }

          # Now add the last component hash to the array again.
          push (@intermediate, \%last_component_hash);

          # Prepare a new hash object, with the key set to the display port part
          # and value to undef to mark it invalid.
          my %display_port_hash = ();
          $display_port_hash{$last_component_right} = undef;

          # Add this to the return value as well.
          push (@intermediate, \%display_port_hash);
        }
      }
    }
  }

  if (!($error_detected)) {
    $ret = \@intermediate;
  }

  return $ret;
}

# Takes an intermediate options string representation array reference(!) and
# returns a string.
# This is essentially the opposite of parse_options.
# Parsing an options string and passing the result through this function again
# SHOULD (if initial options string has been a valid one to begin with) yield
# the initial options string again.
# On error, returns undef.
sub intermediate_to_string {
  my $ret = undef;
  my $error_detected = 0;

  my $options = shift;

  if ('ARRAY' ne ref ($options)) {
    print {*STDERR} 'Invalid options reference type passed (' . ref ($options) . "), returning undef.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    if (1 == scalar (@{$options})) {
      foreach my $entry (@{$options}) {
        if (!defined ($entry)) {
          print {*STDERR} "Invalid options array passed, returning undef.\n";
          $error_detected = 1;
        }
      }
    }
  }

  if (!($error_detected)) {
    # Last entry should contain the display port part only.
    # We can detect it through counting.
    my $elements_left = @{$options};

    # Handle entries iteratively, merging then into one string.
    foreach my $entry (@{$options}) {
      --$elements_left;

      if (!defined ($entry)) {
        print {*STDERR} "Invalid options entry encountered, returning undef.\n";
        $error_detected = 1;
        last;
      }

      if ('HASH' ne ref ($entry)) {
        print {*STDERR} "Entry in array has invalid type (" . ref ($entry) ."), returning undef.\n";
        $error_detected = 1;
        last;
      }

      if (1 < scalar (keys (%{$entry}))) {
        print {*STDERR} "More than one entry encountered in hash of current element, returning undef.\n";
        $error_detected = 1;
        last;
      }

      # Must be either empty or have one element, so... go for it.
      if (0 == scalar (keys (%{$entry}))) {
        if (0 != $elements_left) {
          if (defined ($ret)) {
            $ret .= q{,};
          }
          else {
            # Mark first entry as empty. Don't remove this, or else.
            $ret = q{};
          }
        }
        else {
          # Special handling for last element, which is always supposed to
          # contain the display port.
          print {*STDERR} "No entry found in display port hash, returning undef.\n";
          $error_detected = 1;
          last;
        }
      }
      else {
        # This foreach loop may look weird because, at that point, we know that
        # the hash contains one key exactly, but it's still an elegant way to
        # fetch the key and pseudo-iterate over it.
        foreach my $key (keys (%{$entry})) {
          my $tmp = $key;

          if (0 != $elements_left) {
            if (defined ($entry->{$key})) {
              $tmp .= q{=} . $entry->{$key};
            }
          }

          if (defined ($ret)) {
            if (0 != $elements_left) {
              $ret = join (q{,}, ($ret, $tmp));
            }
            else {
              $ret .= $tmp;
            }
          }
          else {
            $ret = $tmp;
          }
        }
      }
    }
  }

  if ($error_detected) {
    $ret = undef;
  }

  return $ret;
}

# Helper for a grep operation on the intermediate options array.
#
# Takes the option to remove, the current element and amount of elements left
# in the array as arguments and returns true if the element is not to be
# removed, false otherwise.
sub filter_option_remove {
  my $ret = 1;
  my $error_detected = 0;
  my $to_remove = shift;
  my $cur_option = shift;
  my $elems_left = shift;

  if (!((defined ($to_remove)) && (defined ($cur_option)) && (defined ($elems_left)))) {
    # Undefined values are an error in this context, but erroring out in a
    # comparison function is... weird, so let's treat such errors as "don't
    # modify the array".
    print {*STDERR} "Invalid options passed to removal filter, keeping entry.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    if ('HASH' ne ref ($cur_option)) {
      print {*STDERR} "Option passed to removal filter is not a hash reference, keeping entry.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    if (1 < scalar (keys (%{$cur_option}))) {
      print {*STDERR} "Option passed to removal filter has more than one entry in hash, keeping entry.\n";
      $error_detected = 1;
    }
  }

  my $to_remove_key = undef;
  my $to_remove_value = undef;
  my @to_remove_kv = split (/=/smx, $to_remove, 2);

  if (!($error_detected)) {
    if (2 < scalar (@to_remove_kv)) {
      print {*STDERR} "Option-to-be-removed string in removal filter has three or more components, this is a bug in $PROGRAM_NAME. Keeping entry.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected) && (0 < $elems_left)) {
    $to_remove_key = shift (@to_remove_kv);

    # Key can be undef if splitting failed, e.g., due to an empty input string.
    # We don't consider this an error, so reset the key to an empty string.
    if (!(defined ($to_remove_key))) {
      $to_remove_key = q{};
    }

    $to_remove_value = shift (@to_remove_kv);

    my $option_key = q{};
    my $option_value = undef;

    foreach my $tmp_option_key (keys (%{$cur_option})) {
      $option_key = $tmp_option_key;
      $option_value = $cur_option->{$tmp_option_key};
    }

    if ($to_remove_key eq $option_key) {
      # Okay, we've got a match. But we might have to also check the value...
      if (defined ($to_remove_value)) {
        # Yep, value must match, too, but beware of undef values in the current
        # option entry.
        if ((defined ($option_value)) && ($to_remove_value eq $option_value)) {
          # Everything matches, mark for removal.
          $ret = 0;
        }
      }
      else {
        $ret = 0;
      }
    }
  }

  return $ret;
}

# Removes an entry from the intermediate options array.
#
# If only a key is specified, removes any entry that matches this key,
# regardless of its value.
#
# If both a key and a value are specified, only matching combinations will be
# removed from the array. That is, if the array already contains such a key
# with either no value or a different value, it will be unaffected.
#
# Returns a reference to a modified copy of the intermediate options array.
#
# On error, returns a reference to undef.
sub remove_option {
  my $ret = undef;
  my $error_detected = 0;

  my $options = shift;
  my $option = shift;

  if ('ARRAY' ne ref ($options)) {
    print {*STDERR} 'Invalid options reference type passed (' . ref ($options) . "), erroring out.\n";
    $error_detected = 1;
  }

  if (!($error_detected)) {
    if (1 == scalar (@{$options})) {
      foreach my $entry (@{$options}) {
        if (!defined ($entry)) {
          print {*STDERR} "Invalid options array passed, erroring out.\n";
          $error_detected = 1;
        }
      }
    }
  }

  if (!($error_detected)) {
    if (!(defined ($option))) {
      print {*STDERR} "No or invalid option to be removed passed, erroring out.\n";
      $error_detected = 1;
    }
  }

  if (!($error_detected)) {
    # Set return value to a *deep copy* of our original array.
    $ret = dclone ($options);

    my $elements_left = @{$ret};

    # Let the filter function handle the actual work.
    @{$ret} = grep { filter_option_remove ($option, $_, --$elements_left) } (@{$ret});
  }

  return $ret;
}

Getopt::Long::Configure('gnu_getopt', 'no_auto_abbrev');

my $help = 0;
my $man = 0;
GetOptions('help|?|h' => \$help, 'man' => \$man) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-verbose => 2, -exitval => 0) if $man;

my $options = shift;

my $intermediate = parse_options ($options);

print {*STDERR} Dumper ($intermediate) . "\n";

print {*STDERR} Dumper (intermediate_to_string ($intermediate)) . "\n";

my $option_to_remove = shift;

print {*STDERR} Dumper (remove_option ($intermediate, $option_to_remove)) . "\n";

print {*STDERR} Dumper (intermediate_to_string (remove_option ($intermediate, $option_to_remove))) . "\n";

#my $value = shift;
#my $allow_negative = shift;
#
#if (!(defined ($value))) {
#  print {*STDERR} "No value passed in, assuming empty string.\n";
#  $value = q{};
#}
#
#if (!(defined ($allow_negative))) {
#  $allow_negative = 0;
#}
#
#exit is_int ($value);

exit 1;

__END__

=head1 NAME

x2goupdateoptionsstring - X2Go Agent Options String Manipulator

=head1 SYNOPSIS

=over

=item B<x2goupdateoptionsstring> B<--help>|B<-h>|B<-?>

=item B<x2goupdateoptionsstring> B<--man>

=item B<x2goupdateoptionsstring> I<options> [B<->]I<key>[B<=>I<value>] ...

=back

=head1 DESCRIPTION

B<x2goupdateoptionsstring> is a utility for manipulating options strings as
passed to X2Go Agent/NX Agent.

Called it with the options string as the first parameter and the options you
want to manipulate as additional parameters. At least one additional parameter
must be provided.

It can either add, remove or replace components.

To add or replace a component, pass I<key>[B<=>I<value>] as a parameter. If the
options string does not include a B<key> key, it will be appended to the end of
the options string. If it already exists, either with no value or a different
value, the component will be replaced with the provided value.

To fully remove a component, pass B<->I<key>. To only remove it if it is set to
a specific value, pass B<->I<key>B<=>I<value>.

=head1 OPTIONS

=over 8

=item B<--help>|B<-?>|B<-h>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 EXAMPLE

For an options string such as

 nx/nx,clipboard=both,foo:50

calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50'
'-clipboard'> shall return

 nx/nx,foo:50

while calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50'
'-clipboard=server'> shall return

 nx/nx,clipboard=both,foo:50

Calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50' 'bar'> shall
return

 nx/nx,clipboard=both,foo,bar:50

and calling C<x2goupdateoptionsstring 'nx/nx,clipboard=both,foo:50' 'bar'
'foo=gulp' '-clipboard=client'> shall return

 nx/nx,clipboard=both,foo=gulp,bar:50

=head1 AUTHOR

This manual has been written by Mihai Moldovan <ionic@ionic.de> for the X2Go
project (https://www.x2go.org).

=cut
